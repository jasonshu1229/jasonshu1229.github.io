(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{282:function(t,s,a){"use strict";a.r(s);var r=a(0),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("b",[t._v("文章摘录")]),t._v("："),a("a",{attrs:{href:"https://juejin.im/book/6844733816460804104/section/6844733816549048333",target:"_blank",rel:"noopener noreferrer"}},[t._v("掘金 神三元大佬 - React的Reconciliation 算法原理"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("b",[t._v("编者荐语：")]),t._v("\n本文着重介绍"),a("strong",[t._v("React")]),t._v("的渲染机制————Reconciliation过程，译为"),a("strong",[t._v("协调")]),t._v("，协调过程是React渲染机制中重要的阶段，也为React 16. 8版本出现的"),a("strong",[t._v("React Fiber")]),t._v("思想埋下了深深的种子。")]),t._v(" "),a("h2",{attrs:{id:"react渲染流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react渲染流程"}},[t._v("#")]),t._v(" React渲染流程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghyu14bykrj30e60lajsk.jpg",alt:"React渲染机制"}})]),t._v(" "),a("p",[t._v("图片来源：神三元")]),t._v(" "),a("p",[t._v("如上图所示，React渲染机制大致分为五个步骤：")]),t._v(" "),a("ul",[a("li",[t._v("props或state改变")]),t._v(" "),a("li",[t._v("render函数返回不同的元素树")]),t._v(" "),a("li",[t._v("新旧DOM树对比(diff)")]),t._v(" "),a("li",[t._v("针对差异的地方进行更新")]),t._v(" "),a("li",[t._v("渲染为真实DOM树🌲")])]),t._v(" "),a("p",[t._v("图上表明："),a("strong",[t._v("React")]),t._v("采用的是虚拟DOM（即VDOM），每次属性（props）和状态（state）发生变化的时候，"),a("strong",[t._v("render")]),t._v("函数返回不同的元素树，"),a("strong",[t._v("React")]),t._v("会检测当前返回的元素树和上次渲染的元素树之间的差异，然后针对差异的地方进行更新操作，最后渲染为真实DOM，这就是整个"),a("strong",[t._v("Reconciliation")]),t._v("过程，其 "),a("strong",[t._v("核心")]),t._v("就是进行新旧DOM树对比的diff算法。")]),t._v(" "),a("p",[t._v("为了获得更优秀的性能，首先映入脑海的便是 "),a("strong",[t._v("减少diff的过程")]),t._v("，那么在保证应该更新的节点能够得到更新的前提下，这个diff的过程如何来缩短时间或者最小化避免呢？")]),t._v(" "),a("p",[t._v("答案是利用 "),a("strong",[t._v("shouleComponentUpdate")]),t._v("这个生命周期函数。这个函数做了什么事情呢？")]),t._v(" "),a("p",[t._v("默认的 "),a("strong",[t._v("shouleComponentUpdate")]),t._v(" 会在"),a("strong",[t._v("props")]),t._v("或"),a("strong",[t._v("state")]),t._v("发生变化时返回true，表示组件会重新渲染，从而调用render函数，进行新旧DOM树的diff对比。但是我们可以在这个生命周期函数里面做一些判断，然后返回一个"),a("strong",[t._v("布尔值")]),t._v("，并且返回"),a("strong",[t._v("true")]),t._v("表示即将更新当前组件，false则不更新当前组件。换句话说，我们可以通过 "),a("strong",[t._v("shouleComponentUpdate")]),t._v("控制是否发生VDOM树的diff过程。")]),t._v(" "),a("p",[t._v("关键的知识点已经做好了铺垫。现在我们以 React 官方的一个图为例，完整地分析一下 Reconciliation 的流程:")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghyuh0l3oqj30ff0abaaq.jpg",alt:"diff过程"}})]),t._v(" "),a("p",[t._v("图片来源：神三元")]),t._v(" "),a("p",[t._v("SCU 即 shouldComponentUpdate 的简写，图中的"),a("strong",[t._v("红色节点")]),t._v("表示 "),a("strong",[t._v("shouldComponentUpdate 函数返回 true")]),t._v(" ，需要调用 render 方法，进行新旧 VDOM 树的 diff 过程，"),a("strong",[t._v("绿色节点")]),t._v("表示此函数返回 "),a("strong",[t._v("false")]),t._v(" ，不需要进行 DOM 树的更新。")]),t._v(" "),a("p",[t._v("从 C1 开始，C1 为红色节点，shouldComponentUpdate 返回 true，需要进行进一步的新旧 VDOM 树的比对，假设现在两棵树上的 C1 "),a("strong",[t._v("节点类型相同")]),t._v("，则递归进入下一层节点的比较，首先进入 C2，绿色节点，表示 SCU 返回 false，"),a("strong",[t._v("不需要对 C2 的 VDOM 节点进行比对")]),t._v("，同时 "),a("strong",[t._v("C2 下面所有的后代节点")]),t._v(" 都不需要比对。")]),t._v(" "),a("p",[t._v("现在进入 C3，C3 为红色节点，表示 SCU 为 true，需要在该节点上进行比对，假设两棵树的 "),a("strong",[t._v("C3 节点类型相同")]),t._v("，则继续进入到下一层的比对中。其 r 中 C6 为红色节点，进行相应的 diff 操作，C7、C8 都为绿色节点，都不需要更新。")]),t._v(" "),a("p",[t._v("当然可能你会有疑问，上面都是在 diff 的时候假设节点类型相同，那如果节点类型不相同的时候会怎样呢？这里 React 的做法非常简单粗暴，直接将 "),a("strong",[t._v("原 VDOM 树上该节点以及该节点下所有的后代节点")]),t._v(" 全部删除，然后替换为新 VDOM 树上同一位置的节点，当然这个节点的后代节点也全都跟着过来了。这属于 diff 算法的实现细节，我们在文末的彩蛋中会对于 diff 更全面和细致的拆解：）")]),t._v(" "),a("p",[t._v("因此我们可以发现，如果能够合理利用 "),a("b",[t._v("shouldComponentUpdate，从而能避免不必要的 Reconciliation 过程")]),t._v("，使得应用性能可以更加优秀。")]),t._v(" "),a("p",[t._v("但是用了"),a("strong",[t._v("函数式组件")]),t._v("后是不是就没有了浅比较的方案了呢？并不是。React 为函数组件提供了一个 "),a("strong",[t._v("React. memo")]),t._v(" 方法，它和 PureComponent 在数据比对上唯一的区别就在于 "),a("strong",[t._v("只进行了 props 的浅比较")]),t._v(" 。而且它的用法很简单，直接将函数传入 memo 中导出即可。形如:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Home")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//xxx")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Home"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n")])])]),a("p",[t._v("这也就解释了为什么我们需要用在每个组件导出时都要加 memo 包裹。")]),t._v(" "),a("h2",{attrs:{id:"react-memo源码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-memo源码"}},[t._v("#")]),t._v(" React. memo源码")]),t._v(" "),a("p",[a("strong",[t._v("React. memo")]),t._v("内部其实是基于shouldComponentUpdate，实现了一个 "),a("strong",[t._v("Object. is")]),t._v("浅比较新老状态和新老属性，如果一致的话，返回true，不一致返回false")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("OldComponent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("extends")]),t._v(" React"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" Component"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shouldComponentUpdate")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("nextProps"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nextState")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" nextProps "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("props "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" nextState "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("state\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("OldComponent"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"彩蛋-react虚拟dom的diff原理全解析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#彩蛋-react虚拟dom的diff原理全解析"}},[t._v("#")]),t._v(" 彩蛋: React虚拟DOM的Diff原理全解析")]),t._v(" "),a("p",[t._v("谈到 React, diff 算法几乎是一个避不开的话题，因为它对于应用性能来说实在非常重要，但本小节的主角是 shouldComponentUpdate, 因此在正文只是有所提及，现在在彩蛋部分我们就来彻底地整理一下 React 虚拟 DOM 的 diff 算法究竟是如何做的。其实整个过程并不难，难的是它的源码对于边界情况和其他细节的处理，但精通源码，那是参与 React 框架开发的人要做的，我们要做的只是明白其中的原理，以此来帮助我们的应用开发。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghyvh3mz8rj30zk0f6dhx.jpg",alt:"Diff算法规范"}})]),t._v(" "),a("p",[t._v("图片来源：神三元")]),t._v(" "),a("p",[t._v("接下来一一地对其中的过程进行拆解。")]),t._v(" "),a("h3",{attrs:{id:"设计思想概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计思想概述"}},[t._v("#")]),t._v(" 设计思想概述")]),t._v(" "),a("p",[t._v("首先是设计思想，其实从一个树参照另一棵树进行更新，如果利用循环递归的方式对每一个节点进行比较，那算法的复杂度可以到达是 O (n^3), 通俗点来说 1000 个节点的树，要比对 10 亿次，还不包括比对类型、属性等等节点的细节，即使目前性能最高的 CPU 也很难再一秒内算出结果。")]),t._v(" "),a("p",[t._v("但是 React 说它的 diff 就是能达到 O (n) 级别。")]),t._v(" "),a("p",[t._v("不可思议吧！但它其实就是偷工减料，并没有老老实实地比对每一个节点，有一套自己的方法论，简单的归纳一下就是下面三条:")]),t._v(" "),a("ol",[a("li",[t._v("永远只比较同层节点，不会跨层级比较节点。")]),t._v(" "),a("li",[t._v("不同的两个节点产生不同的树。这也就是上面总结的类型不相同的情况，把原来的节点以及它的后代全部干掉，替换成新的。")]),t._v(" "),a("li",[t._v("通过 key 值指定哪些元素是相同的。")])]),t._v(" "),a("h3",{attrs:{id:"执行规则-流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行规则-流程"}},[t._v("#")]),t._v(" 执行规则 (流程)")]),t._v(" "),a("h4",{attrs:{id:"_1、元素类型不相同时"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、元素类型不相同时"}},[t._v("#")]),t._v(" 1、元素类型不相同时")]),t._v(" "),a("p",[t._v("拆卸以该节点为根的树并且建立起新的树。")]),t._v(" "),a("h4",{attrs:{id:"_2-元素类型相同时"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-元素类型相同时"}},[t._v("#")]),t._v(" 2. 元素类型相同时")]),t._v(" "),a("h5",{attrs:{id:"a-都是-dom-节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-都是-dom-节点"}},[t._v("#")]),t._v(" a. 都是 DOM 节点")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div className"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"old"')]),t._v(" title"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"老节点"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div className"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"new"')]),t._v(" title"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"新节点"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("通过比对这两个元素，React 知道需要修改 DOM 元素上的 className 属性和 title 属性。")]),t._v(" "),a("p",[t._v("处理完该节点后，React 继续对子节点进行递归。")]),t._v(" "),a("h5",{attrs:{id:"b-都是组件元素"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-都是组件元素"}},[t._v("#")]),t._v(" b. 都是组件元素")]),t._v(" "),a("p",[t._v("组件实例保持不变，更新 props。值得注意的是，这时候调用组件实例的 "),a("strong",[t._v("componentWillReceiveProps()")]),t._v(" 方法。然后通过 "),a("strong",[t._v("shouldComponentUpdate")]),t._v(" 返回值决定是否调用 render 方法。")]),t._v(" "),a("p",[t._v("处理完该节点后，依然继续对子节点进行递归。")]),t._v(" "),a("h3",{attrs:{id:"特殊情况讨论：遍历子元素列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特殊情况讨论：遍历子元素列表"}},[t._v("#")]),t._v(" 特殊情况讨论：遍历子元素列表")]),t._v(" "),a("h4",{attrs:{id:"引入-key-值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引入-key-值"}},[t._v("#")]),t._v(" 引入 key 值")]),t._v(" "),a("p",[t._v("首先，我们往列表末尾插入一个元素:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("插入后为:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("React 会先匹配两个对应的树，最后插入第三个元素，没有任何问题。")]),t._v(" "),a("p",[t._v("但是如果在头部插入呢？")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("此时前两个元素和原来都不一样，第三个元素被当作新增的节点，明明只需要更新 1 个节点，现在更新了 3 个。这样的情况效率是非常低的。")]),t._v(" "),a("p",[t._v("于是，React 引入了 "),a("strong",[t._v("key")]),t._v(" 值的概念。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"first"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"second"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("插入之后变为:")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"third"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"first"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("li key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"second"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("li"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ul"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),a("p",[t._v("现在 React 通过 key 得知 1 和 2 原来是存在的，现在只是换了位置，因此不需要更新整个节点了，只需要移动位置即可，大大提升效率。")]),t._v(" "),a("h2",{attrs:{id:"选取key值的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#选取key值的问题"}},[t._v("#")]),t._v(" 选取key值的问题")]),t._v(" "),a("p",[t._v("key 选取的原一般是 "),a("strong",[t._v("不需要全局唯一，但必须列表中保持唯一")]),t._v("。")]),t._v(" "),a("p",[t._v("有很多人喜欢用数组元素的下标作为 "),a("strong",[t._v("key")]),t._v(" 值，在"),a("strong",[t._v("元素顺序不改变")]),t._v("的情况是没有问题的，但一旦"),a("strong",[t._v("顺序发生改变")]),t._v("，diff "),a("strong",[t._v("效率")]),t._v("就有可能骤然"),a("strong",[t._v("下降")]),t._v("。")]),t._v(" "),a("p",[t._v("举个例子，现在在五个元素中插入 F")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghyvq2yuboj30hu08c74i.jpg",alt:""}})]),t._v(" "),a("p",[t._v("图片来源：神三元")]),t._v(" "),a("p",[t._v("现在由于 F 的插入，后面的 C、D、E 索引值都改变，即 key 值改变，因此后面的节点都得更新。而且，数组乱序或者在头部插入都会导致同样的更新问题。")]),t._v(" "),a("blockquote",[a("p",[t._v("因此，不用数组索引做 key 值的根本原因在于：数组下标值不稳定，修改顺序会修改当前 key")])]),t._v(" "),a("p",[t._v("当我们利用 key 值以后，上面的问题便迎刃而解，后面的 C、D、E 只需要向后挪动一个位置即可，真正需要更新的就只有新增的节点了。")]),t._v(" "),a("h3",{attrs:{id:"不建议使用数组下表作为key值的例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不建议使用数组下表作为key值的例子"}},[t._v("#")]),t._v(" 不建议使用数组下表作为key值的例子")]),t._v(" "),a("p",[t._v("当好有一个数组列表[a, b, c]，以数组索引作为key值时，其key值分别为0，1，2。")]),t._v(" "),a("p",[t._v("当通过"),a("strong",[t._v("unshift")]),t._v("方法向数组的开头添加元素时，[d, a, b, c]，其key值分别为0，1，2，3；新添加的元素索引为"),a("strong",[t._v("0")]),t._v("，其key值也为"),a("strong",[t._v("0")]),t._v("，而这也导致了之前key值为0 1和2的，变成了1，2和3，所以都需要被动更新。导致了性能问题")]),t._v(" "),a("blockquote",[a("p",[t._v("故：不建议用数组下表作为key值")])]),t._v(" "),a("p",[t._v("那么。我们在常规的列表渲染中，"),a("strong",[t._v("key")]),t._v("属性的值得最佳实践是什么呢？")]),t._v(" "),a("p",[a("b",[t._v("答案：")]),t._v("前后端协作，后端指定唯一标识，前端设置这个标识为key")]),t._v(" "),a("h3",{attrs:{id:"看完三件事❤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#看完三件事❤"}},[t._v("#")]),t._v(" 看完三件事❤")]),t._v(" "),a("p",[t._v("如果你觉得这篇内容对你还蛮有帮助，我想邀请你帮我三个小忙：")]),t._v(" "),a("ol",[a("li",[t._v("点赞，转发，有你们的「"),a("strong",[t._v("在看")]),t._v("」，才是我创造的动力。")]),t._v(" "),a("li",[t._v("关注公众号 『"),a("strong",[t._v("前端时光屋")]),t._v("』，不定期分享原创知识。")]),t._v(" "),a("li",[t._v("同时可以期待后续文章ing🚀")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/007S8ZIlly1ghwblar34nj31yh0u04e7.jpg",alt:""}})])])}),[],!1,null,null,null);s.default=e.exports}}]);