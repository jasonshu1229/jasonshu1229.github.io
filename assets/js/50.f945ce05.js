(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{264:function(v,_,t){"use strict";t.r(_);var r=t(0),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"垃圾收集的背景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集的背景"}},[v._v("#")]),v._v(" 垃圾收集的背景")]),v._v(" "),t("p",[v._v("    Javascript具有"),t("strong",[v._v("自动垃圾收集机制")]),v._v("，也就是说，执行完井会"),t("strong",[v._v("自己")]),v._v("负责管理代码执行过程中使用的内存；而早C和C++之类的语言中，垃圾回收机制是需要开发人员手工跟踪内存的使用情况，这也是，造成内存泄漏的一个根源。\n"),t("br"),t("br"),v._v("\n    垃圾收集器必须跟踪那个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有以下两个策略。")]),v._v(" "),t("h2",{attrs:{id:"策略①-——-标记清除"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#策略①-——-标记清除"}},[v._v("#")]),v._v(" 策略① —— 标记清除")]),v._v(" "),t("p",[v._v("    最常用的垃圾收集方式是"),t("strong",[v._v("标记清除")]),v._v("，当变量进入环境时，将这个变量标记为"),t("strong",[v._v("进入环境")]),v._v("，当变量被用完，离开环境时，标记为"),t("strong",[v._v("离开环境")]),v._v("。\n"),t("br"),t("br"),v._v("\n    垃圾收集器在运行的时候会给存储在内存中的"),t("strong",[v._v("所有变量")]),v._v("都加上"),t("strong",[v._v("标记")]),v._v("。然后它会去掉环境中的变量以及被环境中的变量"),t("strong",[v._v("引用的变量的标记")]),v._v("。而在此之后再被加上标记的变量将被视为"),t("strong",[v._v("准备删除")]),v._v("的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁哪些带标记的值，并回收它们所占用的"),t("strong",[v._v("内存空间")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"策略②-——-引用计数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#策略②-——-引用计数"}},[v._v("#")]),v._v(" 策略② —— 引用计数")]),v._v(" "),t("p",[v._v("    另一种不太常见的垃圾收集策略叫"),t("b",[v._v("引用计数")]),v._v("。引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并被赋值了引用类型的值，则这个值的引用次数就是1，与此同时如果再被赋予变量的话，则引用次数加1。相反如果包含对这个"),t("strong",[v._v("值")]),v._v("的引用的"),t("strong",[v._v("变量")]),v._v("，又取得了另外一个新"),t("strong",[v._v("值")]),v._v("，则这个值得引用次数减1，当减到0的时候，就会释放这个值所占用的"),t("strong",[v._v("内存")]),v._v("。")]),v._v(" "),t("p",[t("b",[v._v("弊端：")]),v._v("循环引用问题和IE9以前的浏览器都会到这引用计数的算法有问题。")]),v._v(" "),t("h2",{attrs:{id:"管理内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#管理内存"}},[v._v("#")]),v._v(" 管理内存")]),v._v(" "),t("p",[v._v("    最主要的一个问题，就是分配给"),t("strong",[v._v("Web浏览器")]),v._v("的"),t("strong",[v._v("可用内存数量")]),v._v("通常要比分配给"),t("strong",[v._v("桌面应用程序")]),v._v("的"),t("strong",[v._v("少")]),v._v("。这样做的目的主要是由于安全方面的考虑。目的是防止JS的网页"),t("strong",[v._v("耗尽")]),v._v("全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，还会影响"),t("strong",[v._v("调用栈")]),v._v("以及在一个"),t("strong",[v._v("线程")]),v._v("中能够"),t("strong",[v._v("同时")]),v._v("执行的"),t("strong",[v._v("语句数量")]),v._v(".\n一般通过将其值设置为null来释放其引用——"),t("b",[v._v("解除引用")]),v._v("。"),t("br"),t("br"),v._v("\n    不过，解除一个值得引用并不意味着自动"),t("strong",[v._v("回收该值")]),v._v("所占用的内存，解除引用的真正"),t("strong",[v._v("作用")]),v._v("是让"),t("strong",[v._v("值脱离执行环境")]),v._v("，以便垃圾收集器下次运行将其回收。")]),v._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("ul",[t("li",[v._v("离开作用域的值将被自动标记为可以回收，因为将在垃圾收集器件被删除。")]),v._v(" "),t("li",[t("strong",[v._v("标记清除")]),v._v("是目前主流的垃圾收集算法，这种算法的思想是"),t("strong",[v._v("给当前不使用的值标记，然后再回收其内存")]),v._v("。")]),v._v(" "),t("li",[v._v("另一种垃圾手机算法是"),t("strong",[v._v("引用计数")]),v._v("，这种算法的思想是"),t("strong",[v._v("跟踪记录所有值被引用的次数")]),v._v("，JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（DOM元素）时，这种算法仍然可能会导致问题。")]),v._v(" "),t("li",[v._v('当代码中存在循环引用现象时，"引用计数"算法就会导致问题。')])]),v._v(" "),t("p",[t("br"),t("br"),v._v("\n-- 本篇博客来自于《JavaScript》高级程序设计（第三版）4.3章节")])])}),[],!1,null,null,null);_.default=s.exports}}]);