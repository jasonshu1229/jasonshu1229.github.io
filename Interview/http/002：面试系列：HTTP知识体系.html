<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | 前端时光屋</title>
    <meta name="description" content="梁书豪的博客">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/assets/img/head.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.83ce72a3.css" as="style"><link rel="preload" href="/assets/js/app.06b24de5.js" as="script"><link rel="preload" href="/assets/js/2.a05443f6.js" as="script"><link rel="preload" href="/assets/js/13.f2fcf962.js" as="script"><link rel="prefetch" href="/assets/js/10.a5eaa95a.js"><link rel="prefetch" href="/assets/js/11.06e35382.js"><link rel="prefetch" href="/assets/js/12.140f4db6.js"><link rel="prefetch" href="/assets/js/14.e39a2df6.js"><link rel="prefetch" href="/assets/js/15.b07ecf86.js"><link rel="prefetch" href="/assets/js/16.949e4dac.js"><link rel="prefetch" href="/assets/js/17.6a721f97.js"><link rel="prefetch" href="/assets/js/18.1b363edf.js"><link rel="prefetch" href="/assets/js/19.900530d5.js"><link rel="prefetch" href="/assets/js/20.e9f183ae.js"><link rel="prefetch" href="/assets/js/21.6c08f73f.js"><link rel="prefetch" href="/assets/js/22.c37ad609.js"><link rel="prefetch" href="/assets/js/23.759a99ff.js"><link rel="prefetch" href="/assets/js/24.c8f3fa94.js"><link rel="prefetch" href="/assets/js/25.b58c3ab8.js"><link rel="prefetch" href="/assets/js/26.ba5e0c3b.js"><link rel="prefetch" href="/assets/js/27.ad23a71d.js"><link rel="prefetch" href="/assets/js/28.a74c53ca.js"><link rel="prefetch" href="/assets/js/29.30ef0dde.js"><link rel="prefetch" href="/assets/js/3.a21791ca.js"><link rel="prefetch" href="/assets/js/30.1e9ebdb5.js"><link rel="prefetch" href="/assets/js/31.30b7a1e3.js"><link rel="prefetch" href="/assets/js/32.9f1ded02.js"><link rel="prefetch" href="/assets/js/33.61ac7552.js"><link rel="prefetch" href="/assets/js/34.f040c739.js"><link rel="prefetch" href="/assets/js/35.2c5d08d5.js"><link rel="prefetch" href="/assets/js/36.257c41df.js"><link rel="prefetch" href="/assets/js/37.40a1bbc2.js"><link rel="prefetch" href="/assets/js/38.5415ab64.js"><link rel="prefetch" href="/assets/js/39.90b605f0.js"><link rel="prefetch" href="/assets/js/4.21591d40.js"><link rel="prefetch" href="/assets/js/40.5e9ae863.js"><link rel="prefetch" href="/assets/js/41.884155d7.js"><link rel="prefetch" href="/assets/js/42.1ec6dd60.js"><link rel="prefetch" href="/assets/js/43.47cf7283.js"><link rel="prefetch" href="/assets/js/44.7af49fad.js"><link rel="prefetch" href="/assets/js/45.6088e1a9.js"><link rel="prefetch" href="/assets/js/46.fd004b63.js"><link rel="prefetch" href="/assets/js/47.044fc351.js"><link rel="prefetch" href="/assets/js/48.55a5f3fb.js"><link rel="prefetch" href="/assets/js/49.e103d7ad.js"><link rel="prefetch" href="/assets/js/5.db726197.js"><link rel="prefetch" href="/assets/js/50.f945ce05.js"><link rel="prefetch" href="/assets/js/51.316d410a.js"><link rel="prefetch" href="/assets/js/52.92a10b4a.js"><link rel="prefetch" href="/assets/js/53.e7534ba4.js"><link rel="prefetch" href="/assets/js/54.6b19fef9.js"><link rel="prefetch" href="/assets/js/55.e3fc3b29.js"><link rel="prefetch" href="/assets/js/56.0e152b3e.js"><link rel="prefetch" href="/assets/js/57.13187b13.js"><link rel="prefetch" href="/assets/js/58.d9bda000.js"><link rel="prefetch" href="/assets/js/59.da580bc1.js"><link rel="prefetch" href="/assets/js/6.ecb72c20.js"><link rel="prefetch" href="/assets/js/60.285d6cbd.js"><link rel="prefetch" href="/assets/js/61.2cdcce13.js"><link rel="prefetch" href="/assets/js/62.cf643bd2.js"><link rel="prefetch" href="/assets/js/63.137e165f.js"><link rel="prefetch" href="/assets/js/64.ce851e8d.js"><link rel="prefetch" href="/assets/js/65.8e7d5299.js"><link rel="prefetch" href="/assets/js/66.4369c90e.js"><link rel="prefetch" href="/assets/js/67.c769b698.js"><link rel="prefetch" href="/assets/js/68.bf74184c.js"><link rel="prefetch" href="/assets/js/69.17c602b3.js"><link rel="prefetch" href="/assets/js/7.6cbb1600.js"><link rel="prefetch" href="/assets/js/70.55df3357.js"><link rel="prefetch" href="/assets/js/71.4fccac4a.js"><link rel="prefetch" href="/assets/js/72.d4eeaf2a.js"><link rel="prefetch" href="/assets/js/73.30f9528a.js"><link rel="prefetch" href="/assets/js/74.4e91b153.js"><link rel="prefetch" href="/assets/js/75.cbd8b825.js"><link rel="prefetch" href="/assets/js/76.72f7b4b9.js"><link rel="prefetch" href="/assets/js/77.a30e1989.js"><link rel="prefetch" href="/assets/js/78.3c4b8b32.js"><link rel="prefetch" href="/assets/js/79.0897d95d.js"><link rel="prefetch" href="/assets/js/8.36911a7c.js"><link rel="prefetch" href="/assets/js/80.43c8044b.js"><link rel="prefetch" href="/assets/js/81.89c13b3c.js"><link rel="prefetch" href="/assets/js/82.df5cf081.js"><link rel="prefetch" href="/assets/js/83.885deed2.js"><link rel="prefetch" href="/assets/js/84.4ed1e2fa.js"><link rel="prefetch" href="/assets/js/85.8bade5eb.js"><link rel="prefetch" href="/assets/js/86.d39c8dda.js"><link rel="prefetch" href="/assets/js/87.15d43505.js"><link rel="prefetch" href="/assets/js/88.ee14fb59.js"><link rel="prefetch" href="/assets/js/89.c5ea7888.js"><link rel="prefetch" href="/assets/js/9.6d6cea10.js"><link rel="prefetch" href="/assets/js/90.2e83c22b.js"><link rel="prefetch" href="/assets/js/91.972a9ec4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.83ce72a3.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端时光屋</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/basics/" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/advance/" class="nav-link">
  进阶
</a></li></ul></div></div><div class="nav-item"><a href="/Vue/base/" class="nav-link">
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="React" class="dropdown-title"><span class="title">React</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/React/basics/" class="nav-link">
  用法
</a></li><li class="dropdown-item"><!----> <a href="/React/advance/" class="nav-link">
  原理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Node" class="dropdown-title"><span class="title">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Node/basics/" class="nav-link">
  用法
</a></li><li class="dropdown-item"><!----> <a href="/Node/advance/" class="nav-link">
  原理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Webpack" class="dropdown-title"><span class="title">Webpack</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Webpack/basics/" class="nav-link">
  用法
</a></li><li class="dropdown-item"><!----> <a href="/Webpack/advance/" class="nav-link">
  原理
</a></li></ul></div></div><div class="nav-item"><a href="/Performance/" class="nav-link">
  性能相关
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试相关" class="dropdown-title"><span class="title">面试相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Interview/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/Interview/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/Interview/react/" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/Interview/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/Interview/http/" class="nav-link router-link-active">
  http
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="JavaScript" class="dropdown-title"><span class="title">JavaScript</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/JavaScript/basics/" class="nav-link">
  基础
</a></li><li class="dropdown-item"><!----> <a href="/JavaScript/advance/" class="nav-link">
  进阶
</a></li></ul></div></div><div class="nav-item"><a href="/Vue/base/" class="nav-link">
  Vue
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="React" class="dropdown-title"><span class="title">React</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/React/basics/" class="nav-link">
  用法
</a></li><li class="dropdown-item"><!----> <a href="/React/advance/" class="nav-link">
  原理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Node" class="dropdown-title"><span class="title">Node</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Node/basics/" class="nav-link">
  用法
</a></li><li class="dropdown-item"><!----> <a href="/Node/advance/" class="nav-link">
  原理
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Webpack" class="dropdown-title"><span class="title">Webpack</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Webpack/basics/" class="nav-link">
  用法
</a></li><li class="dropdown-item"><!----> <a href="/Webpack/advance/" class="nav-link">
  原理
</a></li></ul></div></div><div class="nav-item"><a href="/Performance/" class="nav-link">
  性能相关
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="面试相关" class="dropdown-title"><span class="title">面试相关</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/Interview/js/" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/Interview/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/Interview/react/" class="nav-link">
  react
</a></li><li class="dropdown-item"><!----> <a href="/Interview/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-item"><!----> <a href="/Interview/http/" class="nav-link router-link-active">
  http
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试官系列之http知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Interview/http/001：面试官：cookie、session、localStorage、sessionStorage异同.html" class="sidebar-link">001：面试官：cookie、session、localStorage、sessionStorage异同</a></li><li><a href="/Interview/http/002：面试系列：HTTP知识体系.html" class="active sidebar-link">002：面试系列：HTTP知识体系</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#谈一谈http协议优缺点" class="sidebar-link">谈一谈HTTP协议优缺点</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#http-1-0-http1-1-http2-0版本之间的差异" class="sidebar-link">HTTP/1. 0 HTTP1. 1 HTTP2. 0版本之间的差异</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#谈一谈你对http-2理解" class="sidebar-link">谈一谈你对HTTP/2理解</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#介绍一下http-常见状态码" class="sidebar-link">介绍一下HTTP 常见状态码</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#dns如何工作的" class="sidebar-link">DNS如何工作的</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#dns-为什么使用-udp-协议作为传输层协议？" class="sidebar-link">DNS 为什么使用 UDP 协议作为传输层协议？</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#介绍一下connection-keep-alive" class="sidebar-link">介绍一下Connection:keep-alive</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#介绍http-缓存策略" class="sidebar-link">介绍HTTP 缓存策略</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#说一说http-的请求方法？" class="sidebar-link">说一说HTTP 的请求方法？</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#谈一谈get-和-post-的区别" class="sidebar-link">谈一谈GET 和 POST 的区别</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#options-方法有什么用？" class="sidebar-link">options 方法有什么用？</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#谈一谈你对url理解" class="sidebar-link">谈一谈你对URL理解</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#谈一谈队头阻塞问题" class="sidebar-link">谈一谈队头阻塞问题</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#谈一谈http数据传输" class="sidebar-link">谈一谈HTTP数据传输</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#介绍一下https和http区别" class="sidebar-link">介绍一下HTTPS和HTTP区别</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#介绍一个https工作原理" class="sidebar-link">介绍一个HTTPS工作原理</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#ssl-连接断开后如何恢复？" class="sidebar-link">SSL 连接断开后如何恢复？</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#短轮询、长轮询和-websocket-间的区别？" class="sidebar-link">短轮询、长轮询和 WebSocket 间的区别？</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#说一说正向代理和反向代理" class="sidebar-link">说一说正向代理和反向代理</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#负载平衡的两种实现方式？" class="sidebar-link">负载平衡的两种实现方式？</a></li><li class="sidebar-sub-header"><a href="/Interview/http/002：面试系列：HTTP知识体系.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/Interview/http/003：面试官：说一下浏览器缓存.html" class="sidebar-link">003：面试官：说一下浏览器缓存</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>这次梳理的篇幅主要是涉及网络部分，包括HTTP等，对巩固自己的网络知识体系也是很有帮助的，进一步的对性能优化而言也是帮助很大的。</p> <p>但更多的是抛砖引玉，希望对你们有所帮助。</p> <blockquote><p>感谢掘金大佬 TianTianUp 提供的文章，也谢谢大家的支持🌹</p></blockquote> <blockquote><p>本文囊括了HTTP大部分高频考点，让我们一起来掌握以下。</p></blockquote> <p>接下来就以问题的形式展开梳理👇</p> <h2 id="谈一谈http协议优缺点"><a href="#谈一谈http协议优缺点" class="header-anchor">#</a> 谈一谈HTTP协议优缺点</h2> <p>超文本传输协议，<strong>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范</strong>。</p> <h3 id="http-特点"><a href="#http-特点" class="header-anchor">#</a> HTTP 特点</h3> <ol><li><strong>灵活可扩展</strong>。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。</li> <li><strong>请求-应答模式</strong>，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。</li> <li><strong>可靠传输</strong>，HTTP是基于TCP/IP，因此把这一特性继承了下来。</li> <li><strong>无状态</strong>，指服务端无法对同一客户端的多次http请求进行跟踪。</li></ol> <h3 id="http-缺点"><a href="#http-缺点" class="header-anchor">#</a> HTTP 缺点</h3> <ol><li><strong>无状态</strong>，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。</li> <li><strong>明文传输</strong>，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。</li> <li><strong>队头阻塞</strong>，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。</li></ol> <hr> <h2 id="http-1-0-http1-1-http2-0版本之间的差异"><a href="#http-1-0-http1-1-http2-0版本之间的差异" class="header-anchor">#</a> HTTP/1. 0 HTTP1. 1 HTTP2. 0版本之间的差异</h2> <h3 id="http-0-9"><a href="#http-0-9" class="header-anchor">#</a> HTTP 0. 9</h3> <ul><li>1991年, 原型版本，功能简陋，只有一个命令GET, 只支持纯文本内容，该版本已过时。</li></ul> <h3 id="http-1-0"><a href="#http-1-0" class="header-anchor">#</a> HTTP 1. 0</h3> <ul><li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。</li> <li>除了GET命令，还引入了POST命令和HEAD命令。</li> <li>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。</li> <li>只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。</li> <li>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li> <li>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</li></ul> <h3 id="http-1-1"><a href="#http-1-1" class="header-anchor">#</a> HTTP 1. 1</h3> <p>http1. 1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。</p> <ul><li>引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 <strong>keep-alive</strong> 来设置</li> <li>引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个 请求，进一步改进了HTTP协议的效率。</li> <li>HTTP 1. 1 中新增加了 E-tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存控制标头来控制缓存失效。</li> <li>支持断点续传，通过使用请求头中的 <strong>Range</strong> 来实现。</li> <li>使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li> <li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li></ul> <h3 id="http1-x版本问题"><a href="#http1-x版本问题" class="header-anchor">#</a> http1. x版本问题</h3> <ul><li>在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</li> <li>HTTP/1. 1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。</li> <li>http/1. x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。</li></ul> <h3 id="http-2-0"><a href="#http-2-0" class="header-anchor">#</a> HTTP 2. 0</h3> <ul><li><strong>二进制分帧</strong> 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为&quot;帧&quot;：头信息帧和数据帧。</li> <li><strong>头部压缩</strong> HTTP 1. 1版本会出现 <strong>User-Agent、Cookie、Accept、Server、Range</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2. 0 使用 <strong>HPACK</strong> 算法进行压缩。</li> <li><strong>多路复用</strong> 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。</li> <li><strong>服务器推送</strong> 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li> <li><strong>请求优先级</strong> 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul> <hr> <h2 id="谈一谈你对http-2理解"><a href="#谈一谈你对http-2理解" class="header-anchor">#</a> 谈一谈你对HTTP/2理解</h2> <h3 id="头部压缩"><a href="#头部压缩" class="header-anchor">#</a> 头部压缩</h3> <p>HTTP 1. 1版本会出现 <strong>User-Agent、Cookie、Accept、Server、Range</strong> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。</p> <p>HTTP 2. 0 使用 <strong>HPACK</strong> 算法进行压缩。</p> <p>那我们看看<strong>HPACK</strong>算法吧👇</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghx59jr2z2j30z60gowi4.jpg" alt=""></p> <blockquote><p>从上面看，我们可以看到类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把<strong>索引</strong>(比如1，2，... )传给对方即可，对方拿到索引查表就行了。</p></blockquote> <p>这种<strong>传索引</strong>的方式，可以说让请求头字段得到极大程度的精简和复用。</p> <p>其次是对于整数和字符串进行<strong>哈夫曼编码</strong>，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的<strong>索引序列</strong>，可以达到非常高的压缩率。</p> <h3 id="多路复用"><a href="#多路复用" class="header-anchor">#</a> 多路复用</h3> <p>HTTP 1. x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p> <p>HTTP2中：</p> <ul><li>同域名下所有通信都在单个连接上完成。</li> <li>单个连接可以承载任意数量的双向数据流。</li> <li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是<strong>Stream ID</strong>，流标识符，有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。</li></ul> <h3 id="服务器推送"><a href="#服务器推送" class="header-anchor">#</a> 服务器推送</h3> <p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源，这样浏览器就不用发起后续请求。</p> <p>相比较http/1. 1的优势👇</p> <ul><li>推送资源可以由不同页面共享</li> <li>服务器可以按照优先级推送资源</li> <li>客户端可以缓存推送的资源</li> <li>客户端可以拒收推送过来的资源</li></ul> <h3 id="二进制分帧"><a href="#二进制分帧" class="header-anchor">#</a> 二进制分帧</h3> <p>之前是明文传输，不方便计算机解析，对于回车换行符来说到底是内容还是分隔符，都需要内部状态机去识别，这样子效率低，HTTP/2采用二进制格式，全部传输01串，便于机器解码。</p> <p>这样子一个报文格式就被拆分为一个个二进制帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据。这样子的话，就是一堆乱序的二进制帧，它们不存在先后关系，因此不需要排队等待，解决了HTTP队头阻塞问题。</p> <p>在客户端与服务器之间，双方都可以互相发送二进制帧，这样子<strong>双向传输的序列</strong>，称为<strong>流</strong>，所以HTTP/2中以流来表示一个TCP连接上进行多个数据帧的通信，这就是多路复用概念。</p> <p>那乱序的二进制帧，是如何组装成对于的报文呢？</p> <ul><li>所谓的乱序，值的是不同ID的Stream是乱序的，对于同一个Stream ID的帧是按顺序传输的。</li> <li>接收方收到二进制帧后，将相同的Stream ID组装成完整的请求报文和响应报文。</li> <li>二进制帧中有一些字段，控制着<strong>优先级</strong>和<strong>流量控制</strong>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。</li></ul> <hr> <h2 id="介绍一下http-常见状态码"><a href="#介绍一下http-常见状态码" class="header-anchor">#</a> 介绍一下HTTP 常见状态码</h2> <p>RFC 规定 HTTP 的状态码为<strong>三位数</strong>，第一个数字定义了响应的类别，被分为五类:</p> <ul><li><strong>1xx</strong>: 代表请求已被接受，需要继续处理。</li> <li><strong>2xx</strong>: 表示成功状态。</li> <li><strong>3xx</strong>: 重定向状态。</li> <li><strong>4xx</strong>: 客户端错误。</li> <li><strong>5xx</strong>: 服务器端错误。</li></ul> <h3 id="_1xx-信息类"><a href="#_1xx-信息类" class="header-anchor">#</a> 1xx 信息类</h3> <p>接受的请求正在处理，信息类状态码。</p> <h3 id="_2xx-成功"><a href="#_2xx-成功" class="header-anchor">#</a> 2xx 成功</h3> <ul><li>200 OK 表示从客户端发来的请求在服务器端被正确请求。</li> <li>204 No content，表示请求成功，但没有资源可返回。</li> <li>206 Partial Content，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求 响应报文中包含由 <strong>Content-Range</strong> 指定范围的实体内容。</li></ul> <h3 id="_3xx-重定向"><a href="#_3xx-重定向" class="header-anchor">#</a> 3xx 重定向</h3> <ul><li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL，这时应该按 Location 首部字段提示的 URI 重新保存。</li> <li>302 found，临时性重定向，表示资源临时被分配了新的 URL。</li> <li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源。</li> <li>304 not modified，当协商缓存命中时会返回这个状态码。</li> <li>307 temporary redirect，临时重定向，和302含义相同, 不会改变method。</li></ul> <blockquote><p>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做</p></blockquote> <h3 id="_4xx-客户端错误"><a href="#_4xx-客户端错误" class="header-anchor">#</a> 4XX 客户端错误</h3> <ul><li>400 bad request，请求报文存在语法错误。</li> <li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息。</li> <li>403 forbidden，表示对请求资源的访问被服务器拒绝。</li> <li>404 not found，表示在服务器上没有找到请求的资源。</li> <li>405 Method Not Allowed，服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法，如下 👇</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Allow<span class="token operator">-</span>Methods →<span class="token constant">GET</span><span class="token punctuation">,</span> <span class="token constant">HEAD</span><span class="token punctuation">,</span> <span class="token constant">PUT</span><span class="token punctuation">,</span> <span class="token constant">PATCH</span><span class="token punctuation">,</span> <span class="token constant">POST</span><span class="token punctuation">,</span> <span class="token constant">DELETE</span>
</code></pre></div><h3 id="_5xx-服务器错误"><a href="#_5xx-服务器错误" class="header-anchor">#</a> 5XX 服务器错误</h3> <ul><li>500 internal sever error，表示服务器端在执行请求时发生了错误。</li> <li>502 Bad Gateway，服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li> <li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li></ul> <hr> <h2 id="dns如何工作的"><a href="#dns如何工作的" class="header-anchor">#</a> DNS如何工作的</h2> <p>DNS 协议提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。是应用层协议，通常该协议运行在UDP协议之上，使用的是53端口号。</p> <p><strong>我们通过一张图来看看它的查询过程吧</strong>👇</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghx5g58f0yj30zk06mwf5.jpg" alt="DNS工作流程"></p> <p>这张图很生动的展示了DNS在本地DNS服务器是如何查询的，<strong>一般向本地DNS服务器发送请求是递归查询的</strong></p> <p>本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程👇</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghx5ha1shcj30xm0jsta0.jpg" alt="本地DNS查询"></p> <h3 id="递归查询和迭代查询"><a href="#递归查询和迭代查询" class="header-anchor">#</a> 递归查询和迭代查询</h3> <ul><li>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li> <li>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li></ul> <p>所以一般而言，<strong>本地服务器查询是递归查询</strong>，而<strong>本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程</strong>。</p> <h3 id="dns缓存"><a href="#dns缓存" class="header-anchor">#</a> DNS缓存</h3> <p>缓存也很好理解，在一个请求中，当某个DNS服务器收到一个DNS回答后，它能够回答中的信息缓存在本地存储器中。<strong>返回的资源记录中的 TTL 代表了该条记录的缓存的时间。</strong></p> <h3 id="dns实现负载平衡"><a href="#dns实现负载平衡" class="header-anchor">#</a> DNS实现负载平衡</h3> <p>它是如何实现负载均衡的呢？首先我们得清楚DNS 是可以用于在冗余的服务器上实现负载平衡。</p> <p>**原因：**这是因为一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应 多个服务器地址。</p> <p>举个例子来说👇</p> <ul><li>当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合</li> <li>在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。</li> <li>以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li>DNS域名系统，是应用层协议，运行UDP协议之上，使用端口43。</li> <li>查询过程，本地查询是递归查询，依次通过浏览器缓存 <strong>—&gt;&gt;</strong> 本地hosts文件 <strong>—&gt;&gt;</strong> 本地DNS解析器 **—&gt;&gt;**本地DNS服务器 <strong>—&gt;&gt;</strong> 其他域名服务器请求。 接下来的过程就是迭代过程。</li> <li>递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。</li></ul> <h2 id="dns-为什么使用-udp-协议作为传输层协议？"><a href="#dns-为什么使用-udp-协议作为传输层协议？" class="header-anchor">#</a> DNS 为什么使用 UDP 协议作为传输层协议？</h2> <p><strong>DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。</strong></p> <ul><li>为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。</li> <li>大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</li></ul> <hr> <h2 id="介绍一下connection-keep-alive"><a href="#介绍一下connection-keep-alive" class="header-anchor">#</a> 介绍一下Connection:keep-alive</h2> <h3 id="什么是keep-alive"><a href="#什么是keep-alive" class="header-anchor">#</a> 什么是keep-alive</h3> <p>我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；</p> <p>当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p> <h3 id="为什么要使用keep-alive"><a href="#为什么要使用keep-alive" class="header-anchor">#</a> 为什么要使用keep-alive</h3> <p>keep-alive技术的创建目的，能在多次HTTP之前重用同一个TCP连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），参考如下示意图（来源：维基百科）：</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghx5j55p6sj30fb096aam.jpg" alt=""></p> <h3 id="客户端如何开启"><a href="#客户端如何开启" class="header-anchor">#</a> 客户端如何开启</h3> <p>在HTTP/1. 0协议中，默认是关闭的，需要在http头加入**&quot;Connection: Keep-Alive&quot;<strong>，才能启用</strong>Keep-Alive**；</p> <div class="language-js extra-class"><pre class="language-js"><code>Connection<span class="token operator">:</span> keep<span class="token operator">-</span>alive
</code></pre></div><p><strong>http 1. 1</strong>中默认启用Keep-Alive，如果加入**&quot;Connection: close&quot;** ，才关闭。</p> <div class="language-js extra-class"><pre class="language-js"><code>Connection<span class="token operator">:</span> close
</code></pre></div><p>目前大部分浏览器都是用http1. 1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。</p> <hr> <h2 id="介绍http-缓存策略"><a href="#介绍http-缓存策略" class="header-anchor">#</a> 介绍HTTP 缓存策略</h2> <p>这个跟之前的浏览器缓存原理一样，我直接拿我之前梳理过的吧。</p> <p>我在我之前的那一篇中已经详细的说过了，<a href="https://mp.weixin.qq.com/s/AbypizWR1pT1zhRNtAZikg" target="_blank" rel="noopener noreferrer">点这里传送门聊一聊浏览器缓存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>我们来梳理一下吧👇</p> <h3 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> 强缓存</h3> <p>强缓存两个相关字段，<strong>Expires</strong>，<strong>Cache-Control</strong>。</p> <p><strong>强缓存分为两种情况，一种是发送HTTP请求，一种不需要发送。</strong></p> <p>首先检查强缓存，这个阶段**不需要发送HTTP请求。**通过查找不同的字段来进行，不同的HTTP版本所以不同。</p> <ul><li>HTTP1. 0版本，使用的是Expires，HTTP1. 1使用的是Cache-Control</li></ul> <h4 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h4> <p><strong>Expires</strong>即过期时间，时间是相对于服务器的时间而言的，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:</p> <div class="language-js extra-class"><pre class="language-js"><code>Expires<span class="token operator">:</span> Mon<span class="token punctuation">,</span> <span class="token number">29</span> Jun <span class="token number">2020</span> <span class="token number">11</span><span class="token operator">:</span><span class="token number">10</span><span class="token operator">:</span><span class="token number">23</span> <span class="token constant">GMT</span>
</code></pre></div><p>表示该资源在2020年<strong>7月29日11:10:23</strong>过期，过期时就会重新向服务器发起请求。</p> <p>这个方式有一个问题：<strong>服务器的时间和浏览器的时间可能并不一致</strong>，所以HTTP1. 1提出新的字段代替它。</p> <h4 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h4> <p>HTTP1. 1版本中，使用的就是该字段，这个字段采用的时间是过期时长，对应的是max-age。</p> <div class="language-js extra-class"><pre class="language-js"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span>max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">6000</span>
</code></pre></div><p>上面代表该资源返回后6000秒，可以直接使用缓存。</p> <p>当然了，它还有其他很多关键的指令，梳理了几个重要的👇</p> <blockquote><p>注意点：</p> <ul><li>当Expires和Cache-Control同时存在时，优先考虑Cache-Control。</li> <li>当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存👇</li></ul></blockquote> <h3 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h3> <p>强缓存失效后，浏览器在请求头中携带响应的<strong>缓存Tag</strong>来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。</p> <p>缓存分为两种，<strong>Last-Modified</strong> 和 <strong>ETag</strong>。两者各有优势，并不存在谁对谁有<strong>绝对的优势</strong>，与上面所讲的强缓存两个Tag所不同。</p> <h4 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h4> <p>这个字段表示的是<strong>最后修改时间</strong>。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</p> <p>浏览器接收到后，<strong>如果再次请求</strong>，会在请求头中携带<strong>If-Modified-Since</strong>字段，这个字段的值也就是服务器传来的最后修改时间。</p> <p>服务器拿到请求头中的<strong>If-Modified-Since</strong>的字段后，其实会和这个服务器中<strong>该资源的最后修改时间</strong>对比:</p> <ul><li>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。</li> <li>否则返回304，告诉浏览器直接使用缓存。</li></ul> <h4 id="etag"><a href="#etag" class="header-anchor">#</a> ETag</h4> <p>ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，服务器通过把响应头把该字段给浏览器。</p> <p>浏览器接受到ETag值，会在下次请求的时候，将这个值作为<strong>If-None-Match</strong>这个字段的内容，发给服务器。</p> <p>服务器接收到<strong>If-None-Match</strong>后，会跟服务器上该资源的<strong>ETag</strong>进行比对👇</p> <ul><li>如果两者一样的话，直接返回304，告诉浏览器直接使用缓存</li> <li>如果不一样的话，说明内容更新了，返回新的资源，跟常规的HTTP请求响应的流程一样</li></ul> <h4 id="两者对比"><a href="#两者对比" class="header-anchor">#</a> 两者对比</h4> <ul><li>性能上，<strong>Last-Modified</strong>优于<strong>ETag</strong>，<strong>Last-Modified</strong>记录的是时间点，而<strong>Etag</strong>需要根据文件的MD5算法生成对应的hash值。</li> <li>精度上，<strong>ETag</strong>优于<strong>Last-Modified</strong>。ETag按照内容给资源带上标识，能准确感知资源变化，Last-Modified在某些场景并不能准确感知变化，比如👇
<ul><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li> <li><strong>Last-Modified</strong> 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li></ul></li></ul> <p>最后，<strong>「如果两种方式都支持的话，服务器会优先考虑ETag」</strong>。</p> <h3 id="缓存位置"><a href="#缓存位置" class="header-anchor">#</a> 缓存位置</h3> <p>接下来我们考虑使用缓存的话，缓存的位置在哪里呢？</p> <p>浏览器缓存的位置的话，可以分为四种, 优先级从高到低排列分别👇</p> <ul><li>Service Worker</li> <li>Memory Cache</li> <li>Disk Cache</li> <li>Push Cache</li></ul> <h4 id="service-worker"><a href="#service-worker" class="header-anchor">#</a> Service Worker</h4> <p>这个应用场景比如PWA，它借鉴了Web Worker思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：<strong>离线缓存</strong>、<strong>消息推送</strong>和<strong>网络代理</strong>，其中<strong>离线缓存</strong>就是 <strong>Service Worker Cache</strong>。</p> <h4 id="memory-cache"><a href="#memory-cache" class="header-anchor">#</a> Memory Cache</h4> <p>指的是内存缓存，从效率上讲它是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p> <h4 id="disk-cache"><a href="#disk-cache" class="header-anchor">#</a> Disk Cache</h4> <p>存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。</p> <h4 id="disk-cache-vs-memory-cache"><a href="#disk-cache-vs-memory-cache" class="header-anchor">#</a> Disk Cache VS Memory Cache</h4> <p>两者对比，主要的策略👇</p> <p>内容使用率高的话，文件优先进入磁盘</p> <p>比较大的JS，CSS文件会直接放入磁盘，反之放入内存。</p> <h4 id="push-cache"><a href="#push-cache" class="header-anchor">#</a> Push Cache</h4> <p>推送缓存，这算是浏览器中最后一道防线吧，它是<strong>HTTP/2</strong>的内容。具体我也不是很清楚，有兴趣的可以去了解。</p> <h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <ul><li>首先检查<strong>Cache-Control</strong>， 尝鲜，看强缓存是否可用</li> <li>如果可用的话，直接使用</li> <li>否则进入协商缓存，发送HTTP请求，服务器通过请求头中的<strong>If-Modified-Since</strong>或者<strong>If-None-Match</strong>字段检查资源是否更新</li> <li>资源更新，返回资源和200状态码。</li> <li>否则，返回304，直接告诉浏览器直接从缓存中去资源。</li></ul> <hr> <h2 id="说一说http-的请求方法？"><a href="#说一说http-的请求方法？" class="header-anchor">#</a> 说一说HTTP 的请求方法？</h2> <ul><li>HTTP1. 0定义了三种请求方法： GET, POST 和 HEAD方法</li> <li>HTTP1. 1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT</li></ul> <p><strong>http/1. 1</strong>规定了以下请求方法(注意，都是大写):</p> <ul><li>GET： 请求获取Request-URI所标识的资源</li> <li>POST： 在Request-URI所标识的资源后附加新的数据</li> <li>HEAD： 请求获取由Request-URI所标识的资源的响应消息报头</li> <li>PUT： 请求服务器存储一个资源，并用Request-URI作为其标识（修改数据）</li> <li>DELETE： 请求服务器删除对应所标识的资源</li> <li>TRACE： 请求服务器回送收到的请求信息，主要用于测试或诊断</li> <li>CONNECT： 建立连接隧道，用于代理服务器</li> <li>OPTIONS： 列出可对资源实行的请求方法，用来跨域请求</li></ul> <h2 id="谈一谈get-和-post-的区别"><a href="#谈一谈get-和-post-的区别" class="header-anchor">#</a> 谈一谈GET 和 POST 的区别</h2> <p>本质上，只是语义上的区别，GET 用于获取资源，POST 用于提交资源。</p> <p>具体差别👇</p> <ul><li>从缓存角度看，GET 请求后浏览器会主动缓存，POST 默认情况下不能。</li> <li>从参数角度来看，GET请求一般放在URL中，因此不安全，POST请求放在请求体中，相对而言较为安全，但是在抓包的情况下都是一样的。</li> <li>从编码角度看，GET请求只能经行URL编码，只能接受ASCII码，而POST支持更多的编码类型且不对数据类型限值。</li> <li>GET请求幂等，POST请求不幂等，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。</li> <li>GET请求会一次性发送请求报文，POST请求通常分为两个TCP数据包，首先发 header 部分，如果服务器响应 100(continue)，然后发 body 部分。</li></ul> <p>从应用场景角度来看，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</p> <hr> <h2 id="options-方法有什么用？"><a href="#options-方法有什么用？" class="header-anchor">#</a> options 方法有什么用？</h2> <ul><li>OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。</li> <li>这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。</li> <li>JS 的 XMLHttpRequest对象进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li></ul> <h2 id="谈一谈你对url理解"><a href="#谈一谈你对url理解" class="header-anchor">#</a> 谈一谈你对URL理解</h2> <p>统一资源定位符的简称，Uniform Resource Locator，常常被称为网址，是因特网上标准的资源地址。</p> <h3 id="组成"><a href="#组成" class="header-anchor">#</a> 组成</h3> <p>通用的格式：scheme://host[:port]/path/…/?query#anchor</p> <table><thead><tr><th>名称</th> <th>功能</th></tr></thead> <tbody><tr><td>scheme</td> <td>访问服务器以获取资源时要使用哪种协议，比如：http，https 和 FTP 等</td></tr> <tr><td>host</td> <td>HTTP 服务器的 IP 地址或者域名</td></tr> <tr><td>port</td> <td>HTTP 服务器的默认端口是 80，HTTPS默认端口是443，这种情况下端口号可以省略，如果使用了别的端口，必须指明。不同的端口，你可以认为是不同的应用程序。</td></tr> <tr><td>path</td> <td>访问资源的路径</td></tr> <tr><td>query-string</td> <td>发给 http 服务器的数据</td></tr> <tr><td>anchor</td> <td>锚点</td></tr></tbody></table> <p>举个例子👇</p> <div class="language-js extra-class"><pre class="language-js"><code>https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com<span class="token operator">/</span>s<span class="token operator">?</span>tn<span class="token operator">=</span>baidu<span class="token operator">&amp;</span>bar<span class="token operator">=</span><span class="token operator">&amp;</span>wd<span class="token operator">=</span>TianTian
</code></pre></div><p>这个URL中，https就是协议，<a href="http://www.baidu.xn--com%2C443%2C-m30n8mr27ag5meu5aea2970fg4vc0hxd/s%E5%B0%B1%E6%98%AF%E8%AF%B7%E6%B1%82%E7%9A%84path%EF%BC%8C" target="_blank" rel="noopener noreferrer">www. baidu. com就是域名，默认端口是443，/s就是请求的path，<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><strong>tn=baidu&amp;bar=&amp;wd=TianTian</strong>这个就是query。</p> <h3 id="url-编码"><a href="#url-编码" class="header-anchor">#</a> URL 编码</h3> <ul><li>URL 只能使用 <a href="https://www.w3school.com.cn/tags/html_ref_ascii.asp" target="_blank" rel="noopener noreferrer">ASCII 字符集<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来通过因特网进行发送。</li> <li>由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</li> <li>URL 编码使用 &quot;%&quot; 其后跟随两位的十六进制数来替换非 ASCII 字符。</li> <li>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</li></ul> <p>举个例子👇</p> <div class="language-html extra-class"><pre class="language-html"><code>天天**转换为有效的ASCII格式就是**%CC%EC%CC%EC
</code></pre></div><hr> <h2 id="谈一谈队头阻塞问题"><a href="#谈一谈队头阻塞问题" class="header-anchor">#</a> 谈一谈队头阻塞问题</h2> <h3 id="什么是队头阻塞？"><a href="#什么是队头阻塞？" class="header-anchor">#</a> 什么是队头阻塞？</h3> <p>对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<strong>HTTP队头阻塞</strong>问题。</p> <p>有什么解决办法吗👇</p> <h3 id="并发连接"><a href="#并发连接" class="header-anchor">#</a> 并发连接</h3> <p>我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务，在<strong>RFC规范</strong>中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。</p> <h3 id="域名分片"><a href="#域名分片" class="header-anchor">#</a> 域名分片</h3> <p>顾名思义，我们可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器，这样子的话就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题。</p> <p>举个例子，比如<strong>TianTian. com</strong>，可以分出很多二级域名，比如<strong>Day1. TianTian. com</strong>，<strong>Day2. TianTian. com</strong>, <strong>Day3. TianTian. com</strong>, 这样子就可以有效解决队头阻塞问题。</p> <hr> <h2 id="谈一谈http数据传输"><a href="#谈一谈http数据传输" class="header-anchor">#</a> 谈一谈HTTP数据传输</h2> <p>大概遇到的情况就分为<strong>定长数据</strong> 与 <strong>不定长数据</strong>的处理吧。</p> <h3 id="定长数据"><a href="#定长数据" class="header-anchor">#</a> 定长数据</h3> <p>对于定长的数据包而言，发送端在发送数据的过程中，需要设置<strong>Content-Length</strong>, 来指明发送数据的长度。</p> <p>当然了如果采用了Gzip压缩的话，Content-Length设置的就是压缩后的传输长度。</p> <p>我们还需要知道的是👇</p> <ul><li>Content-Length如果存在并且有效的话，则必须和消息内容的传输长度完全一致，也就是说，如果过短就会截断，过长的话，就会导致超时。</li> <li>如果采用短链接的话，直接可以通过服务器关闭连接来确定消息的传输长度。</li> <li>那么在HTTP/1. 0之前的版本中，Content-Length字段可有可无, 因为一旦服务器关闭连接，我们就可以获取到传输数据的长度了。</li> <li>在HTTP/1. 1版本中，如果是Keep-alive的话，chunked优先级高于<strong>Content-Length</strong>, 若是非Keep-alive，跟前面情况一样，Content-Length可有可无。</li></ul> <p>那怎么来设置<strong>Content-Length</strong></p> <p>举个例子来看看👇</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> server <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
server<span class="token punctuation">.</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span> url <span class="token operator">===</span> <span class="token string">'/index'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 设置数据类型</span>

    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/plain'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;你好，使用的是Content-Length设置传输数据形式&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

server<span class="token punctuation">.</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;成功启动--TinaTian&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="不定长数据"><a href="#不定长数据" class="header-anchor">#</a> 不定长数据</h3> <p>现在采用最多的就是HTTP/1. 1版本，来完成传输数据，在保存Keep-alive状态下，当数据是不定长的时候，我们需要设置新的头部字段👇</p> <div class="language-js extra-class"><pre class="language-js"><code>Transfer<span class="token operator">-</span>Encoding<span class="token operator">:</span> chunked
</code></pre></div><p>通过chunked机制，可以完成对不定长数据的处理，当然了，你需要知道的是</p> <ul><li>如果头部信息中有<strong>Transfer-Encoding</strong>, 优先采用Transfer-Encoding里面的方法来找到对应的长度。</li> <li>如果设置了Transfer-Encoding，那么Content-Length将被忽视。</li> <li>使用长连接的话，会持续的推送动态内容。</li></ul> <p>那我们来模拟一下吧👇</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> server <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
server<span class="token punctuation">.</span> <span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'request'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span> url <span class="token operator">===</span> <span class="token string">'/index'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  	<span class="token comment">// 设置数据类型</span>

    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'text/html; charset=utf8'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Length'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">setHeader</span><span class="token punctuation">(</span><span class="token string">'Transfer-Encoding'</span><span class="token punctuation">,</span> <span class="token string">'chunked'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;你好，使用的是Transfer-Encoding设置传输数据形式&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;第一次传输数据给您&lt;br/&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;骚等一下&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;第一次传输数据给您&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

server<span class="token punctuation">.</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;成功启动--TinaTian&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面使用的是nodejs中http模块，有兴趣的小伙伴可以去试一试，以上就是HTTP对 <strong>定长数据</strong>和 <strong>不定长数据</strong> 传输过程中的处理手段。</p> <hr> <h2 id="介绍一下https和http区别"><a href="#介绍一下https和http区别" class="header-anchor">#</a> 介绍一下HTTPS和HTTP区别</h2> <p>HTTPS 要比 HTTPS 多了 secure 安全性这个概念，实际上， HTTPS 并不是一个新的应用层协议，它其实就是 HTTP + TLS/SSL 协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。</p> <p><strong>SSL</strong></p> <p>安全套接层（Secure Sockets Layer）</p> <p><strong>TLS</strong></p> <p>（传输层安全，Transport Layer Security）</p> <p>现在主流的版本是 TLS/1. 2, 之前的 TLS1. 0、TLS1. 1 都被认为是不安全的，在不久的将来会被完全淘汰。</p> <p><strong>HTTPS 就是身披了一层 SSL 的 HTTP</strong>。</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghx662uzo7j30uo0e20tk.jpg" alt="HTTP与HTTPS区别"></p> <p>那么区别有哪些呢👇</p> <ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li> <li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO, 谷歌、百度优先索引HTTPS网页。</li> <li>HTTPS标准端口443，HTTP标准端口80。</li> <li>HTTPS需要用到SSL证书，而HTTP不用。</li></ul> <p>我觉得记住以下两点HTTPS主要作用就行👇</p> <ol><li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;</li> <li>对网站服务器进行真实身份认证。</li></ol> <h2 id="介绍一个https工作原理"><a href="#介绍一个https工作原理" class="header-anchor">#</a> 介绍一个HTTPS工作原理</h2> <p>上一节来看，我们可以把HTTPS理解成 <strong>HTTPS = HTTP + SSL/TLS</strong></p> <blockquote><p>TLS/SSL 的功能实现主要依赖于三类基本算法：<strong>散列函数</strong> 、<strong>对称加密</strong>和<strong>非对称加密</strong>，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p></blockquote> <h3 id="对称加密"><a href="#对称加密" class="header-anchor">#</a> 对称加密</h3> <p>加密和解密用同一个秘钥的加密方式叫做对称加密。Client客户端和Server端共用一套密钥，这样子的加密过程似乎很让人理解，但是随之会产生一些问题。</p> <p><strong>问题一:</strong> WWW万维网有许许多多的客户端，不可能都用秘钥A进行信息加密，这样子很不合理，所以解决办法就是使用一个客户端使用一个密钥进行加密。</p> <p>**问题二:**既然不同的客户端使用不同的密钥，那么 <strong>对称加密的密钥如何传输？</strong> 那么解决的办法只能是 <strong>一端生成一个秘钥，然后通过HTTP传输给另一端</strong>，那么这样子又会产生新的问题。</p> <p><strong>问题三:</strong> 这个传输密钥的过程，又如何保证加密？**如果被中间人拦截，密钥也会被获取, ** 那么你会说对密钥再进行加密，那又怎么保存对密钥加密的过程，是加密的过程？</p> <p>到这里，我们似乎想明白了，使用对称加密的方式，行不通，所以我们需要采用非对称加密👇</p> <h3 id="非对称加密"><a href="#非对称加密" class="header-anchor">#</a> 非对称加密</h3> <p>通过上面的分析，对称加密的方式行不通，那么我们来梳理一下非对称加密。采用的算法是RSA，所以在一些文章中也会看见<strong>传统RSA握手</strong>，基于现在TLS主流版本是1. 2，所以接下来梳理的是<strong>TLS/1. 2握手过程</strong>。</p> <p>非对称加密中，我们需要明确的点是👇</p> <ul><li>有一对秘钥，<strong>公钥</strong>和 <strong>私钥</strong>。</li> <li>公钥加密的内容，只有私钥可以解开，私钥加密的内容，所有的公钥都可以解开，这里说的 <strong>公钥都可以解开，指的是一对秘钥</strong>。</li> <li>公钥可以发送给所有的客户端，私钥只保存在服务器端。</li></ul> <h3 id="主要工作流程"><a href="#主要工作流程" class="header-anchor">#</a> 主要工作流程</h3> <p>梳理起来，可以把<strong>TLS 1. 2 握手过程</strong>分为主要的五步👇</p> <p>图片内容来自<a href="https://juejin.im/user/4283353031252967" target="_blank" rel="noopener noreferrer">浪里行舟<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="步骤-1"><a href="#步骤-1" class="header-anchor">#</a> 步骤(1)</h4> <p>Client发起一个HTTPS请求，连接443端口。这个过程可以理解成是<strong>请求公钥的过程</strong>。</p> <h4 id="步骤-2"><a href="#步骤-2" class="header-anchor">#</a> 步骤(2)</h4> <p>Server端收到请求后，通过第三方机构私钥加密，会把数字证书（也可以认为是公钥证书）发送给Client。</p> <h4 id="步骤-3"><a href="#步骤-3" class="header-anchor">#</a> 步骤(3)</h4> <ul><li>浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。</li> <li>根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。</li> <li>通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。</li></ul> <h4 id="步骤-4"><a href="#步骤-4" class="header-anchor">#</a> 步骤(4)</h4> <p>在安全拿到<strong>服务器公钥</strong>后，客户端Client随机生成一个<strong>对称密钥</strong>，使用<strong>服务器公钥</strong>（证书的公钥）加密这个<strong>对称密钥</strong>，发送给Server(服务器)。</p> <h4 id="步骤-5"><a href="#步骤-5" class="header-anchor">#</a> 步骤(5)</h4> <p>Server(服务器)通过自己的私钥，对信息解密，至此得到了<strong>对称密钥</strong>，此时两者都拥有了相同的<strong>对称密钥</strong>。</p> <p>接下来，就可以通过该对称密钥对传输的信息加密/解密啦，从上面图举个例子👇</p> <ul><li>Client用户使用该<strong>对称密钥</strong>加密'明文内容B', 发送给Server(服务器)</li> <li>Server使用该<strong>对称密钥</strong>进行解密消息，得到明文内容B。</li></ul> <p>接下来考虑一个问题，<strong>如果公钥被中间人拿到纂改怎么办呢？</strong></p> <p>以下图片来自<a href="https://juejin.im/user/694547078451278" target="_blank" rel="noopener noreferrer">leocoder<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghx6b5vvhnj30kl0n6q5t.jpg" alt="中间人获取公钥"></p> <p><strong>客户端可能拿到的公钥是假的，解决办法是什么呢？</strong></p> <h3 id="第三方认证"><a href="#第三方认证" class="header-anchor">#</a> 第三方认证</h3> <p>客户端无法识别传回公钥是中间人的，还是服务器的，这是问题的根本，我们是不是可以通过某种规范可以让客户端和服务器都遵循某种约定呢？那就是通过<strong>第三方认证的方式</strong></p> <p>在HTTPS中，通过 <strong>证书</strong> + <strong>数字签名</strong>来解决这个问题。</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghx6bqutpnj30fg0eljsk.jpg" alt=""></p> <p>这里唯一不同的是，假设对网站信息加密的算法是MD5，通过MD5加密后，<strong>然后通过第三方机构的私钥再次对其加密，生成数字签名</strong>。</p> <p>这样子的话，数字证书包含有两个特别重要的信息👉<strong>某网站公钥+数字签名</strong></p> <p>我们再次假设中间人截取到服务器的公钥后，去替换成自己的公钥，因为有数字签名的存在，这样子客户端验证发现数字签名不匹配，这样子就防止中间人替换公钥的问题。</p> <p>那么客户端是如何去对比两者数字签名的呢？</p> <ul><li>浏览器会去安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等。</li> <li>验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。</li> <li>然后客户端利用签名生成规则进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</li></ul> <h3 id="数字签名作用"><a href="#数字签名作用" class="header-anchor">#</a> 数字签名作用</h3> <p>数字签名：将网站的信息，通过特定的算法加密，比如MD5, 加密之后，再通过服务器的私钥进行加密，形成<strong>加密后的数字签名</strong>。</p> <p>第三方认证机构是一个公开的平台，中间人可以去获取。</p> <p>如果没有数字签名的话，这样子可以就会有下面情况👇</p> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghx6chjka1j30jx0e5tao.jpg" alt=""></p> <p>从上面我们知道，如果<strong>只是对网站信息进行第三方机构私钥加密</strong>的话，还是会受到欺骗。</p> <p>因为没有认证，所以中间人也向第三方认证机构进行申请，然后拦截后把所有的信息都替换成自己的，客户端仍然可以解密，并且无法判断这是服务器的还是中间人的，最后造成数据泄露。</p> <h3 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> <strong>总结</strong></h3> <ul><li>HTTPS就是使用SSL/TLS协议进行加密传输</li> <li>大致流程：客户端拿到服务器的公钥（是正确的），然后客户端随机生成一个<strong>对称加密的秘钥</strong>，使用<strong>该公钥</strong>加密，传输给服务端，服务端再通过解密拿到该<strong>对称秘钥</strong>，后续的所有信息都通过该<strong>对称秘钥</strong>进行加密解密，完成整个HTTPS的流程。</li> <li><strong>第三方认证</strong>，最重要的是<strong>数字签名</strong>，避免了获取的公钥是中间人的。</li></ul> <hr> <h2 id="ssl-连接断开后如何恢复？"><a href="#ssl-连接断开后如何恢复？" class="header-anchor">#</a> SSL 连接断开后如何恢复？</h2> <p>一共有两种方法来恢复断开的 SSL 连接，一种是使用 session ID，一种是 session ticket。</p> <h3 id="通过session-id"><a href="#通过session-id" class="header-anchor">#</a> 通过session ID</h3> <p>使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。</p> <h3 id="通过session-ticket"><a href="#通过session-ticket" class="header-anchor">#</a> 通过session ticket</h3> <p>另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</p> <h2 id="短轮询、长轮询和-websocket-间的区别？"><a href="#短轮询、长轮询和-websocket-间的区别？" class="header-anchor">#</a> 短轮询、长轮询和 WebSocket 间的区别？</h2> <h3 id="短轮询"><a href="#短轮询" class="header-anchor">#</a> 短轮询</h3> <p>短轮询的基本思路:</p> <ul><li>浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行 响应。</li> <li>这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</li></ul> <p>优缺点👇</p> <ul><li>优点是比较简单，易于理解。</li> <li>缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</li></ul> <h3 id="长轮询"><a href="#长轮询" class="header-anchor">#</a> 长轮询</h3> <p>长轮询的基本思路:</p> <ul><li>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将 这个请求挂起，然后判断服务器端数据是否有更新。</li> <li>如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</li></ul> <p>优缺点👇</p> <ul><li>长轮询和短轮询比起来，它的优点是<strong>明显减少了很多不必要的 http 请求次数</strong>，相比之下节约了资源。</li> <li>长轮询的缺点在于，连接挂起也会导致资源的浪费。</li></ul> <h3 id="websocket"><a href="#websocket" class="header-anchor">#</a> WebSocket</h3> <ul><li>WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。</li> <li>使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。</li></ul> <h2 id="说一说正向代理和反向代理"><a href="#说一说正向代理和反向代理" class="header-anchor">#</a> 说一说正向代理和反向代理</h2> <h3 id="正向代理"><a href="#正向代理" class="header-anchor">#</a> 正向代理</h3> <p>我们常说的代理也就是指正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。</p> <h3 id="反向代理"><a href="#反向代理" class="header-anchor">#</a> 反向代理</h3> <p>这种代理模式下，它隐藏了真实的服务端，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务，具体是哪一台，我们不清楚，我们只需要知道反向代理服务器是谁就行，而且反向代理服务器会帮我们把请求转发到真实的服务器那里去，一般而言反向代理服务器一般用来实现负载平衡。</p> <h2 id="负载平衡的两种实现方式？"><a href="#负载平衡的两种实现方式？" class="header-anchor">#</a> 负载平衡的两种实现方式？</h2> <ul><li>一种是使用反向代理的方式，用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。</li> <li>另一种是 DNS 的方式，DNS 可以用于在冗余的服务器上实现负载平衡。因为现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。这种方式有一个缺点就是，由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。</li></ul> <hr> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li><a href="https://zhuanlan.zhihu.com/p/25028045" target="_blank" rel="noopener noreferrer">听说『99% 的人都理解错了 HTTP 中 GET 与 POST 的区别』？？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://harttle.land/2015/08/15/http-status-code.html#header-11" target="_blank" rel="noopener noreferrer">如何理解HTTP响应的状态码？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener noreferrer">HTTP 响应代码 | MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5eb7f811f265da7bbc7cc5bd" target="_blank" rel="noopener noreferrer">图解 HTTP 缓存<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/5e1870736fb9a02fef3a5dcb#heading-40" target="_blank" rel="noopener noreferrer">看完这篇HTTP，跟面试官扯皮就没问题了<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://lotabout.me/2019/Things-about-keepalive/" target="_blank" rel="noopener noreferrer">HTTP keep-alive 二三事<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/6844903830916694030" target="_blank" rel="noopener noreferrer">深入理解HTTPS工作原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://juejin.im/post/6844903608421449742" target="_blank" rel="noopener noreferrer">看图学HTTPS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://cloud.tencent.com/developer/article/1076547" target="_blank" rel="noopener noreferrer">轮询、长轮询、长连接、websocket<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="http://www.ruanyifeng.com/blog/2016/06/dns.html" target="_blank" rel="noopener noreferrer">DNS 原理入门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="看完三件事❤"><a href="#看完三件事❤" class="header-anchor">#</a> 看完三件事❤</h3> <p>如果你觉得这篇内容对你还蛮有帮助，我想邀请你帮我三个小忙：</p> <ol><li>点赞，转发，有你们的「<strong>在看</strong>」，才是我创造的动力。</li> <li>关注公众号 『<strong>前端时光屋</strong>』，不定期分享原创知识。</li> <li>同时可以期待后续文章ing🚀</li></ol> <p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ghwblar34nj31yh0u04e7.jpg" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Interview/http/001：面试官：cookie、session、localStorage、sessionStorage异同.html" class="prev">
        001：面试官：cookie、session、localStorage、sessionStorage异同
      </a></span> <span class="next"><a href="/Interview/http/003：面试官：说一下浏览器缓存.html">
        003：面试官：说一下浏览器缓存
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.06b24de5.js" defer></script><script src="/assets/js/2.a05443f6.js" defer></script><script src="/assets/js/13.f2fcf962.js" defer></script>
  </body>
</html>
